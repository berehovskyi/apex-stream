# v3.3.0


# Table of Contents
<details>
  <summary>Click to expand!</summary>

- [🚀 New Features](#-new-features)
    - [🔀 Apex Common Functions V1 vs V2](#v1-vs-v2)
        - [⚡ Class Aliases](#-class-aliases)
        - [🛠️ Functions](#fn)
        - [🔍 Predicates](#-predicates)
            - [Comparer Predicates](#comparer-predicates)
            - [Iterable Predicates](#iterable-predicates)
            - [String Predicates](#string-predicates)
        - [🛒 Consumers](#-consumers)
        - [🔁 Operators](#-operators)
        - [🚚 Suppliers](#-suppliers)
            - [SObject Suppliers](#sobject-suppliers)
            - [Id Suppliers](#id-suppliers)
            - [String Suppliers](#string-suppliers)
        - [⚖️ BiPredicates](#️bi-pred)
            - [Comparer BiPredicates](#comparer-bipredicates)
        - [🧺 Collectors](#-collectors)
            - [To List Collectors](#to-list-collectors)
            - [To Set Collectors](#to-set-collectors)
            - [To Map Collectors](#to-map-collectors)
            - [Group Collectors](#group-collectors)
            - [Partition Collectors](#partition-collectors)
            - [Join Collectors](#join-collectors)
            - [Aggregate Collectors](#aggregate-collectors)
            - [Filter Collectors](#filter-collectors)
            - [Map Collectors](#map-collectors)
            - [Flat Map Collectors](#flat-map-collectors)
            - [Fold Collectors](#fold-collectors)
            - [Reduce Collectors](#reduce-collectors)
            - [Min and Max Collectors](#min-and-max-collectors)
        - [Cross-Reference Fields and Safe Navigation](#cross-reference-fields-and-safe-navigation)
- [🗓️ Next Steps](#-next-steps)
</details>

# 🚀 New Features:

- Apex Common Functions V2 (Pilot Release)

## 🔀 Apex Common Functions V2 (Pilot Release) <a id="v1-vs-v2"></a>

Provides a fluent API for common Apex functions.

| Apex Common Functions V1                 | Apex Common Functions V2            |
|------------------------------------------|-------------------------------------|
| Set of heavily overloaded static methods | Fluent API                          |
| Focused on Object <- SObject hierarchy   | Focused primarily on SObjects       |
| Less intuitive syntax                    | More expressive and readable syntax |
|                                          | Supports method chaining            |
|                                          | Supports class aliases              |

### ⚡ Class Aliases

Class aliases allow you to create a more concise or intuitive reference for a class without changing its original
functionality. The aliased classes are **exactly the same as the original classes** and behaves exactly the same as
the original class, retaining all its methods, properties, and behaviors, but it is referenced using a more
**compact or user-friendly** name.
This feature can be particularly useful when dealing with lengthy or complex class names,
making your code more readable and easier to maintain.

Apex Common Functions V2 provides a class alias for each of the common function providers.

| Interface   | Original                                    | Alias         |
|-------------|---------------------------------------------|---------------|
| Predicate   | `SObjectApexComparerPredicateProvider`      | `SApxPred`    |
|             | `SObjectDefaultComparerPredicateProvider`   | `SDefPred`    |
|             | `SObjectIterablePredicateProvider`          | `SIterPred`   |
|             | `SObjectStringPredicateProvider`            | `SStrPred`    |
| Function    | `SObjectFunctionProvider`                   | `SFn`         |
| Operator    | `SObjectOperatorProvider`                   | `SOp`         |
| Consumer    | `SObjectConsumerProvider`                   | `SCon`        |
| Supplier    | `SObjectSupplierProvider`                   | `SSup`        |
|             | `IdSupplierProvider`                        | `IdSup`       |
|             | `StringSupplierProvider`                    | `StrSup`      |
| Collector   | `SObjectCollectorProvider`                  | `SCol`        |
| BiPredicate | `SObjectApexComparerBiPredicateProvider`    | `SApxBiPred`  |
|             | `SObjectDefaultComparerBiPredicateProvider` | `SDefBiPred`  |


### 🛠️ Functions <a id="fn"/>

Designed to retrieve values from SObjects supporting cross-reference fields, safe navigation, and complex field paths.

Syntax:

```
instance
  .[mapper(get | getSObject | getSObjects | getPopulatedFieldsAsMap | getQuickActionName | getSObjectType)]

OR

instance
  .[chainingMapper(
    mapTo
      .[sourceOperator(val | var)]
      .[targetOperator(to)]
      ...{repeatable}
  )];
```

- Mapper:

| Call                      | Description                                                                                                                             |
|---------------------------|-----------------------------------------------------------------------------------------------------------------------------------------| 
| `get`                     | Returns a `Function` that returns a field value                                                                                         |
| `getSObject`              | Returns a `Function` that returns a parent SObject field value                                                                          |
| `getSObjects`             | Returns a `Function` that returns children SObjects value by relationship field                                                         |
| `getPopulatedFieldsAsMap` | Returns a `Function` that returns a map of populated fields                                                                             |
| `getQuickActionName`      | Returns a `Function` that returns the name of a quick action associated with an input argument                                          |
| `getSObjectType`          | Returns a `Function` that returns the `SObjectType` of an input argument                                                                |
| `mapTo`                   | Takes either a `SObjectType` or `SObjectSupplierProvider` of a target new SObject as an argument and returns the next step in the chain |

- The `mapTo` Chain:

| Call  | Description                                                         |
|-------|---------------------------------------------------------------------|
| `val` | Gets a value from target SObject by field, field name or function   |
| `var` | Gets a value or constant                                            |
| `to`  | Sets a value from `val` or `var` step to a source field, field name |

This chaining mapper is repeatable and useful for mapping SObjects by multiple fields.

Examples

Example 1: Retrieving a Field Value:

```apex
IFunction nameMapper = new SFn().get(Account.Name);
nameMapper.apply(new Account(Name = 'John Doe')); // John Doe
```

Example 2: Mapping Contact to Lead:

```apex
IFunction mapToLead = new SFn().mapTo(Lead.SObjectType)
    .val(Contact.LastName).to(Lead.LastName)
    .val('Email').to('Email')
    .var(someUserId).to('OwnerId');
mapToLead.apply(new Contact(LastName = 'Doe', Email = 'john.doe@example.com'));
// Lead { LastName: 'Doe', Email: 'john.doe@example.com', OwnerId: '005000000000000AAA' }
```


### 🔍 Predicates

Designed to test SObjects for matching conditions, useful for filtering and validating data.

#### Comparer Predicates

Designed to operate logical comparisons such as `==`, `!=`, `>`,
`>=`, and so on. Depending on the type of comparer, there are two variants:

- `SObjectDefaultComparerPredicateProvider`: Satisfies the `IComparer` contract, considering non-null values **as
  always greater than a null value**.
- `SObjectApexComparerPredicateProvider`: Violates the
  `IComparer` contract, comparing nullable values the way it's [designed in Apex](https://developer.salesforce.com/docs/atlas.en-us.apexcode.meta/apexcode/langCon_apex_expressions_operators_understanding.htm), e.g.
  ```42 > null; // false```

Syntax:

```
instance
    .[left(is | isVar)]
    .[operator(gt | ge | lt | le | eq | ne | eqNull | neNull)]
    .[right(val | var)];
```

- Left Operand:

| Call    | Description                                                                    |
|---------|--------------------------------------------------------------------------------| 
| `is`    | Get a left side of comparison based on field, field name, function or identity |
| `isVar` | Get a left side of comparison based on value or constant                       |

- Operators:

| Call     | Operator  |
|----------|-----------|
| `gt`     | `>`       |
| `ge`     | `>=`      |
| `lt`     | `<`       |
| `le`     | `<=`      |
| `eq`     | `==`      |
| `ne`     | `!=`      |
| `eqNull` | `== NULL` |
| `neNull` | `!= NULL` |

- Right Operand:

| Call  | Description                                                                     |
|-------|---------------------------------------------------------------------------------| 
| `val` | Get a right side of comparison based on field, field name, function or identity |
| `var` | Get a right side of comparison based on value or constant                       |

Example:

```apex
IPredicate isRevenueGt1MPredicate = new SDefPred()
    .is(Account.AnnualRevenue)
    .gt()
    .var(1000000);
isRevenueGt1MPredicate.test(new Account(AnnualRevenue = 50000)); // false
isRevenueGt1MPredicate.test(new Account(AnnualRevenue = 2000000)); // true
isRevenueGt1MPredicate.test(new Account(AnnualRevenue = null)); // true but doesn't match Apex behavior
```

📢To match Apex behavior comparing nullable values use `SApxPred` instead of `SDefPred`:

```apex
IPredicate isRevenueGt1MPredicate = new SApxPred()
    .is(Account.AnnualRevenue)
    .gt()
    .var(1000000);
isRevenueGt1MPredicate.test(new Account(AnnualRevenue = 50000)); // false
isRevenueGt1MPredicate.test(new Account(AnnualRevenue = 2000000)); // true
isRevenueGt1MPredicate.test(new Account(AnnualRevenue = null)); // false and matches Apex behavior
```

#### Iterable Predicates

Designed to operate iterable operators such as `IN`, `NOT IN`, `INCLUDES`, `EXCLUDES`.

Syntax:

```
instance
    .[left(is)]
    .[operator(inx | nin | inc | exc)];
```

- Left Operand:

| Call | Description                                                                                     |
|------|-------------------------------------------------------------------------------------------------| 
| `is` | takes a field name (String), field (SObjectField), or function (IFunction) that returns a value |

- Operators:

| Call  | operator   |
|-------|------------|
| `inx` | `IN`       |
| `nin` | `NOT IN`   |
| `inc` | `INCLUDES` |
| `exc` | `EXCLUDES` |

Example:

```apex
List<String> names = new List<String>{ 'John', 'Jane' };
IPredicate inNameInPredicate = new SIterPred()
    .is(Account.Name)
    .inx(names);
inNameInPredicate.test(new Account(Name = 'John')); // true
```

#### String Predicates

Designed to operate string operators such as `BLANK`, `STARTS WITH`, `ENDS WITH`, `LIKE`, `CONTAINS`, etc.

Syntax:

```
instance
    .[left(is)]
    .{optionalNegation(notx)}
    .[operator(blank | empty | containing | startingWith | endingWith | likex)];
```

- Left Operand:

| Call | Description                                                                                              |
|------|----------------------------------------------------------------------------------------------------------|  
| `is` | takes a field name (String), field (SObjectField), or function (IFunction) that returns a `String` value |

- Negation (Optional):

    - `notx`: Negates the result of the predicate.

- Operators:

| Call             | Operation                   | Description                                         |
|------------------|-----------------------------|-----------------------------------------------------|
| `blank`          | `ISBLANK`                   | Checks if value is blank                            |
| `empty`          | `ISEMPTY`                   | Checks if value is empty                            |
| `containing`     | `CONTAINS`                  | Checks if value contains a substring                |
| `containingIc`   | `CONTAINS IGNORING CASE`    | Checks if value contains a substring ignoring case  |
| `startingWith`   | `STARTS WITH`               | Checks if value starts with substring               |
| `startingWithIc` | `STARTS WITH IGNORING CASE` | Checks if value starts with substring ignoring case |
| `endingWith`     | `ENDS WITH`                 | Checks if value ends with substring                 |
| `endingWithIc`   | `ENDS WITH IGNORING CASE`   | Checks if value ends with substring ignoring case   |
| `likex`          | `LIKE`                      | Checks if value matches                             |

Example:

```apex
IPredicate isNameNotBlankPredicate = new SStrPred()
    .is(Account.Name)
    .notx()
    .blank();
isNameNotBlankPredicate.test(new Account(Name = 'John')); // true
isNameNotBlankPredicate.test(new Account(Name = '')); // false
```

### 🛒 Consumers

Designed to mutate SObjects supporting cross-reference fields, safe navigation, and complex field paths.

Syntax:
```
instance
    .[target(set | setSObject)]
    .[value(val | var)]
OR

instance
    .[target(addError)]
    .{optional(escape)}
    .[value({to})];
```

- Target:

| Call         | Description                                       |
|--------------|---------------------------------------------------| 
| `set`        | Defines a target field for update                 |
| `setSObject` | Defines a target parent SObject field for update  |
| `addError`   | Defines an error message or exception to be added |

- Escape (Optional):

    - `escape(true)`: Escapes the error message.

- Value:

| Call  | Description                                                                                            |
|-------|--------------------------------------------------------------------------------------------------------|
| `val` | Sets new value from another field, field name or function                                              |
| `var` | Sets new value from variable or constant                                                               |
| `to`  | (Optional) Defines the field to add the error to. If this call was not made SObject itself is a target |

Examples

Example 1: Setting a Field Value:

```apex
IConsumer setJaneDoeNameConsumer = new SCon()
    .set(Account.Name)
    .var('Jane Doe');
setJaneDoeNameConsumer.accept(new Account()); // { Name: 'Jane Doe' }
setJaneDoeNameConsumer.accept(new Account(Name = 'John Doe')); // { Name: 'Jane Doe' }
```

Example 2: Adding an Error Message:

```apex
IConsumer addErrorConsumer = new SCon()
    .addError('Invalid Field')
    .escape(true)
    .to(Account.Name);
addErrorConsumer.accept(new Account(Name = 'John Doe')); // adds error 'Invalid Field' to Name field
```


### 🔁 Operators

Designed to mutate SObjects supporting cross-reference fields, safe navigation, and complex field paths.
Basically, operators do the same thing as consumers, but they return the mutated SObject.

Syntax:

```
instance
    .[operator(set | setSObject | setSObjects)]
    .[value(val | var)];
```

- Operator:

| Call          | Description                                                                                                                   |
|---------------|-------------------------------------------------------------------------------------------------------------------------------| 
| `set`         | Defines a target field for update                                                                                             |
| `setSObject`  | Defines a target parent SObject field for update                                                                              |
| `setSObjects` | Defines a target children SObjects for update. Uses serialization/deserialization<br/> and doesnt mutate the original SObject |

- Value:

| Call  | Description                                               |
|-------|-----------------------------------------------------------|
| `val` | Sets new value from another field, field name or function |
| `var` | Sets new value from variable or constant                  |

Examples

Example 1: Setting a Field Value:

```apex
IOperator setJohnDoeNameOperator = new SOp()
    .set(Account.Name)
    .var('John Doe');
setJohnDoeNameOperator.apply(new Account()); // { Name: 'John Doe' }
```

Example 2: Setting a Parent SObject:

```apex
IOperator setParentOperator = new SOp()
    .setSObject(Account.ParentId)
    .var(new Account(Name = 'Parent Account'));
setParentOperator.apply(new Account(Name = 'John Doe')); // { Name: 'John Doe', Parent: { Name: 'Parent Account' } }
```

Example 3: Setting Children SObjects:

```apex
List<Contact> contacts = new List<Contact>{ new Contact(FirstName = 'John'), new Contact(FirstName = 'Jane') };
Account original = new Account();
IOperator setContactsOperator = new SOp()
    .setSObjects('Contacts') // or setSObjects(Contact.AccountId)
    .var(contacts);
setContactsOperator.apply(original);
// Account { Contacts: [{ FirstName: 'John' }, { FirstName: 'Jane' }] }
// but the original SObject is not mutated
```


### 🚚 Suppliers

Designed to generate new entities such as SObjects, Ids, or Strings.

#### SObject Suppliers

Designed to generate new SObject instances.

Syntax:

```
instance.[supplier(of)];
```

- Supplier:

| Call | Description                                                                             |
|------|-----------------------------------------------------------------------------------------|
| `of` | Returns a `Supplier` that generates a new `SObject` instance of the given `SObjectType` |

Example:

```apex
ISupplier accountSupplier = new SSup().of(Account.SObjectType);
accountSupplier.get(); // Account {}
```

#### Id Suppliers

Designed to generate new Ids.

Syntax:

```
instance.[supplier(of)];
```

- Supplier:

| Call | Description                                                                        |
|------|------------------------------------------------------------------------------------|
| `of` | Returns a `Supplier` that generates a new `Id` instance of the given `SObjectType` |

Example:

```apex
ISupplier accIdSupplier = new SSup().of(Account.SObjectType);
accIdSupplier.get(); // '001000000000000AAA'
accIdSupplier.get(); // '000000000000001AAA'
accIdSupplier.get(); // '000000000000002AAA'
```

#### String Suppliers

Designed to generate new Strings, such as UUIDs or autonumbers.

Syntax:

```
instance.[supplier(uuid | autonumber)];
```

- Supplier:

| Call         | Description                                                             |
|--------------|-------------------------------------------------------------------------|
| `uuid`       | Returns a `Supplier` that generates a new `UUID` instance               |
| `autonumber` | Returns a `Supplier` that generates a new autonumber for a given format |

Example:

```apex
// UUID
ISupplier uuidSupplier = new StrSup().uuid();
uuidSupplier.get(); // '563581af-5560-a1fd-2291-2b03582bf000'
uuidSupplier.get(); // '57b0a848-68e6-2eb8-96ce-2ec0691f51b8'

// Autonumber
ISupplier autonumberSupplier = new StrSup().autonumber('A-{0000}');
autonumberSupplier.get(); // 'A-0000'
autonumberSupplier.get(); // 'A-0001'
autonumberSupplier.get(); // 'A-0002'
```


### ⚖️ BiPredicates <a id="bi-pred"/>

Designed to test two SObjects (left and right) simultaneously for matching conditions.
Useful for comparing old and new records in trigger contexts.

#### Comparer BiPredicates

Designed to compare 2 SObjects operating logical comparisons such as `==`, `!=`, `>`,
`>=`, and so on. Depending on the type of comparer, there are two variants of the predicate providers:

- `SObjectDefaultComparerBiPredicateProvider`: Satisfies the `IComparer` contract, considering non-null values **as
  always greater than a null value**.
- `SObjectApexComparerBiPredicateProvider`: Violates the
  `IComparer` contract, comparing nullable values the way it's [designed in Apex](https://developer.salesforce.com/docs/atlas.en-us.apexcode.meta/apexcode/langCon_apex_expressions_operators_understanding.htm), e.g.
  ```42 > null; // false```

Syntax:

```
instance
    .[left(isL | isLVar)]
    .[operator(gt | ge | lt | le | eq | ne | eqNull | neNull)]
    .[right(rVal | rVar)];

OR

instance
    .[operator(areEq | areNe)]
```

- Left Operand:

| Call     | Description                                                                               |
|----------|-------------------------------------------------------------------------------------------| 
| `isL`    | Retrieves a left side of comparison based on field value or function of the left argument |
| `isLVar` | Retrieves a left side of comparison as a variable or constant                             |

- Operators:

| Call     | Operator  |
|----------|-----------|
| `gt`     | `>`       |
| `ge`     | `>=`      |
| `lt`     | `<`       |
| `le`     | `<=`      |
| `eq`     | `==`      |
| `ne`     | `!=`      |
| `eqNull` | `== NULL` |
| `neNull` | `!= NULL` |

- Right Operand:

| Call   | Description                                                                                 |
|--------|---------------------------------------------------------------------------------------------|
| `rVal` | Retrieves a right side of comparison based on field value or function of the right argument |
| `rVar` | Retrieves a right side of comparison as a variable or constant                              |

Example:

```apex
IBiPredicate isLeftRevenueGtRightBiPredicate = new SDefBiPred()
    .isL(Account.AnnualRevenue)
    .gt()
    .rVal(Account.AnnualRevenue);
isLeftRevenueGtRightBiPredicate.test(new Account(AnnualRevenue = 50000), new Account(AnnualRevenue = 2000000)); // false
isLeftRevenueGtRightBiPredicate.test(new Account(AnnualRevenue = 100000), new Account(AnnualRevenue = 50000)); // true
isLeftRevenueGtRightBiPredicate.test(new Account(AnnualRevenue = 100000), new Account(AnnualRevenue = null)); // true but doesn't match Apex behavior
```

📢To match Apex behavior comparing nullable values use `SApxBiPred` instead of `SDefBiPred`:

```apex
IBiPredicate isLeftRevenueGtRightBiPredicate = new SApxBiPred()
    .isL(Account.AnnualRevenue)
    .gt()
    .rVal(Account.AnnualRevenue);
isLeftRevenueGtRightBiPredicate.test(new Account(AnnualRevenue = 50000), new Account(AnnualRevenue = 2000000)); // false
isLeftRevenueGtRightBiPredicate.test(new Account(AnnualRevenue = 100000), new Account(AnnualRevenue = 50000)); // true
isLeftRevenueGtRightBiPredicate.test(new Account(AnnualRevenue = 100000), new Account(AnnualRevenue = null)); // false and matches Apex behavior
```


### 🧺 Collectors

Designed to collect elements into various data structures like lists, sets and maps.

#### To List Collectors

Designed to collect elements into a list.

Syntax:

```
instance
    .[target(toList)]
    .{supplier(of)}
    .{value(val)};
```

- Target:

| Call     | Description                                             |
|----------|---------------------------------------------------------|
| `toList` | Defines that the elements will be collected into a list |

- Supplier (Optional):

| Call | Description                                                        |
|------|--------------------------------------------------------------------|
| `of` | Defines a `Supplier` or value `Type` that generates an accumulator |

- Value (optional):

| Call  | Description                                                                   |
|-------|-------------------------------------------------------------------------------|
| `val` | A value to be added to accumulator by field, field name, function or identity |

Example:

```apex
List<Account> accounts = new List<Account>{
    new Account(AnnualRevenue = 10000, Name = 'John Doe'),
    new Account(AnnualRevenue = 20000, Name = 'Jane Smith')
};
// Collect all accounts with AnnualRevenue > 15000 as a list
ICollector toListCollector = new SCol().toList();
List<Account> accounts = (List<Account>) Stream.of(accounts)
    .filter(new SDefPred().is(Account.AnnualRevenue).gt().var(15000))
    .collect(toListCollector);

// Collect all account names
ICollector nameCollector = new SCol()
    .toList()
    .of(String.class)
    .val(Account.Name);
List<String> names = (List<String>) Stream.of(accounts)
     .collect(nameCollector); // ['John Doe', 'Jane Smith']
```

#### To Set Collectors

Designed to collect elements into a set.

Syntax:

```
instance
    .[target(
       | toBoolSet
       | toIdSet
       | toStringSet
       | toBlobSet
       | toDateSet
       | toDatetimeSet
       | toTimeSet
       | toIntSet
       | toLongSet
       | toDoubleSet
       | toSObjectSet
       | toObjectSet
    )]
    .{value(val)}
```

- Target:

| Call            | Description                                                        |
|-----------------|--------------------------------------------------------------------|
| `toBoolSet`     | Defines that the elements will be collected into a `Set<Boolean>`  |
| `toIdSet`       | Defines that the elements will be collected into a `Set<Id>`       |
| `toStringSet`   | Defines that the elements will be collected into a `Set<String>`   |
| `toBlobSet`     | Defines that the elements will be collected into a `Set<Blob>`     |
| `toDateSet`     | Defines that the elements will be collected into a `Set<Date>`     |
| `toDatetimeSet` | Defines that the elements will be collected into a `Set<Datetime>` |
| `toTimeSet`     | Defines that the elements will be collected into a `Set<Time>`     |
| `toIntSet`      | Defines that the elements will be collected into a `Set<Integer>`  |
| `toLongSet`     | Defines that the elements will be collected into a `Set<Long>`     |
| `toDoubleSet`   | Defines that the elements will be collected into a `Set<Double>`   |
| `toSObjectSet`  | Defines that the elements will be collected into a `Set<SObject>`  |
| `toObjectSet`   | Defines that the elements will be collected into a `Set<Object>`   |

⚠️ Apex doesn't support flexible type inference for sets.
This is why we have to specify the type explicitly.

- Value:

| Call  | Description                                                                   |
|-------|-------------------------------------------------------------------------------|
| `val` | A value to be added to accumulator by field, field name, function or identity |

Example:

```apex
List<Contact> contacts = new List<Contact>{
    new Contact(Id = '003000000000000AAA'),
    new Contact(Id = '003000000000001AAA')
};
// Collect all contacts into a Set
ICollector toSetCollector = new SCol()
    .toSObjectSet();
Set<SObject> contacts = (Set<SObject>) Stream.of(contacts)
    .collect(toSetCollector); // { Id: '003000000000000AAA', Id: '003000000000001AAA' }

// Collect all contact ids into a Set
ICollector idCollector = new SCol()
    .toIdSet()
    .val(Contact.Id);
Set<Id> ids = (Set<Id>) Stream.of(contacts)
    .collect(idCollector); // { '003000000000000AAA', '003000000000001AAA' }
```

#### To Map Collectors

Designed to collect elements into a map.

Syntax:

```
instance
    .[target(
       | toByBoolMap
       | toByIdMap
       | toByStringMap
       | toByBlobMap
       | toByDateMap
       | toByDatetimeMap
       | toByTimeMap
       | toByIntMap
       | toByLongMap
       | toByDoubleMap
       | toBySObjectMap
       | toByObjectMap
    )]
    .{supplier(of)}
    .{merger(merger)}
    .[key(key)]
    .{value(val)}
```

- Target:

| Call              | Description                                                         |
|-------------------|---------------------------------------------------------------------|
| `toByBoolMap`     | Defines that the elements will be collected into a Map<Boolean, ?>  |
| `toByIdMap`       | Defines that the elements will be collected into a Map<Id, ?>       |
| `toByStringMap`   | Defines that the elements will be collected into a Map<String, ?>   |
| `toByBlobMap`     | Defines that the elements will be collected into a Map<Blob, ?>     |
| `toByDateMap`     | Defines that the elements will be collected into a Map<Date, ?>     |
| `toByDatetimeMap` | Defines that the elements will be collected into a Map<Datetime, ?> |
| `toByTimeMap`     | Defines that the elements will be collected into a Map<Time, ?>     |
| `toByIntMap`      | Defines that the elements will be collected into a Map<Integer, ?>  |
| `toByLongMap`     | Defines that the elements will be collected into a Map<Long, ?>     |
| `toByDoubleMap`   | Defines that the elements will be collected into a Map<Double, ?>   |
| `toBySObjectMap`  | Defines that the elements will be collected into a Map<SObject, ?>  |
| `toByObjectMap`   | Defines that the elements will be collected into a Map<Object, ?>   |

⚠️ ? Type is defined if the default supplier was overridden by `of` call. Default value type of map is `SObject`.

⚠️ Apex doesn't support flexible type inference for maps.
This is why we have to specify the type explicitly.

- Supplier (Optional):

| Call | Description                                                        |
|------|--------------------------------------------------------------------|
| `of` | Defines a `Supplier` or value `Type` that generates an accumulator |

- Merger (Optional):

| Call     | Description                                        |
|----------|----------------------------------------------------|
| `merger` | Defines a merge function to resolve duplicate keys |

- Key:

| Call  | Description                                                                     |
|-------|---------------------------------------------------------------------------------|
| `key` | A map key to be added to accumulator by field, field name, function or identity |

- Value (Optional):

| Call  | Description                                                                       |
|-------|-----------------------------------------------------------------------------------|
| `val` | A map value to be added to accumulator by field, field name, function or identity |

Example:

```apex
List<Account> accounts = new List<Account>{
    new Account(Industry = 'Technology', Name = 'Company A'),
    new Account(Industry = 'Finance', Name = 'Company B')
};
// Collect all accounts by industry
ICollector accountsByIndustryCollector = new SCol()
    .toBySObjectMap()
    .of(Account.class)
    .key(Account.Industry);
Map<String, Account> accountsByIndustry = (Map<String, Account>) Stream.of(accounts)
    .collect(accountsByIndustryCollector);
// { 'Technology' => { Industry: 'Technology', Name: 'Company A' }, 'Finance' => { Industry: 'Finance', Name: 'Company B' } }

// Collect all account names by industry
ICollector nameByIndustryCollector = new SCol()
    .toByStringMap()
    .of(String.class)
    .key(Account.Industry)
    .val(Account.Name);
Map<String, String> nameByIndustry = (Map<String, String>) Stream.of(accounts)
    .collect(nameByIndustryCollector); // { 'Technology' => 'Company A', 'Finance' => 'Company B' }
```

#### Group Collectors

Designed to collect elements into a group map.

Syntax:

```
instance
    .[target(
       | groupingByBool
       | groupingById
       | groupingByString
       | groupingByBlob
       | groupingByDate
       | groupingByDatetime
       | groupingByTime
       | groupingByInt
       | groupingByLong
       | groupingByDouble
       | groupingBySObject
       | groupingByObject
    )]
    .{supplier(of)}
    .[key(key)]
    .{value(val)}
```

- Target:

| Call                 | Description                                                         |
|----------------------|---------------------------------------------------------------------|
| `groupingByBool`     | Defines that the elements will be collected into a Map<Boolean, ?>  |
| `groupingById`       | Defines that the elements will be collected into a Map<String, ?>   |
| `groupingByString`   | Defines that the elements will be collected into a Map<Blob, ?>     |
| `groupingByBlob`     | Defines that the elements will be collected into a Map<Date, ?>     |
| `groupingByDate`     | Defines that the elements will be collected into a Map<Datetime, ?> |
| `groupingByDatetime` | Defines that the elements will be collected into a Map<Time, ?>     |
| `groupingByTime`     | Defines that the elements will be collected into a Map<Integer, ?>  |
| `groupingByInt`      | Defines that the elements will be collected into a Map<Long, ?>     |
| `groupingByLong`     | Defines that the elements will be collected into a Map<Double, ?>   |
| `groupingByDouble`   | Defines that the elements will be collected into a Map<SObject, ?>  |
| `groupingBySObject`  | Defines that the elements will be collected into a Map<Object, ?>   |

⚠️ ? Type is defined if the default supplier was overridden by `of` call.
Default value type of map is `List<SObject>` and the default downstream collector is `toList`.

⚠️ Apex doesn't support flexible type inference for maps.
This is why we have to specify the type explicitly.

- Supplier (Optional):

| Call | Description                                                        |
|------|--------------------------------------------------------------------|
| `of` | Defines a `Supplier` or value `Type` that generates an accumulator |

- Key:

| Call  | Description                                                                     |
|-------|---------------------------------------------------------------------------------|
| `key` | A map key to be added to accumulator by field, field name, function or identity |

- Value (Optional):

| Call  | Description                                                                        |
|-------|------------------------------------------------------------------------------------|
| `val` | Defines a custom downstream collector by field, field name, downstream or identity |

Examples

Example 1: Simple Grouping by Field

```apex
List<Account> accounts = new List<Account>{
    new Account(Industry = 'Technology', Name = 'Company A'),
    new Account(Industry = 'Finance', Name = 'Company B'),
    new Account(Industry = 'Finance', Name = 'Company C')
};
// Group all accounts by industry
ICollector accountsByIndustryCollector = new SCol()
    .groupingByString()
    .key(Account.Industry);
Map<String, List<Account>> accountsByIndustry = (Map<String, List<Account>>) Stream.of(accounts)
    .collect(accountsByIndustryCollector);
// {
//     'Technology' => [ { Industry: 'Technology', Name: 'Company A' } ],
//     'Finance' => [ { Industry: 'Finance', Name: 'Company B' }, { Industry: 'Finance', Name: 'Company C' } ]
// }
```

Example 2: Grouping Field Values by Field

```apex
// Group account names by industry
ICollector lastNamesByIndustryCollector = new SCol()
    .groupingByString()
    .of(List<String>.class)
    .key(Account.Industry)
    .val(Account.Name);
Map<String, List<String>> lastNamesByIndustry = (Map<String, List<String>>) Stream.of(accounts)
    .collect(lastNamesByIndustryCollector); // { 'Technology' => ['Company A'], 'Finance' => ['Company B', 'Company C'] }

```

Example 3: Grouping Into Custom Downstream Collector

```apex
// Group account names into a set by industry
ICollector lastNamesByIndustryCollector = new SCol()
    .groupingByString()
    .of(Set<String>.class)
    .key(Account.Industry)
    .val(new SCol().toStringSet().val(Account.Name));
Map<String, Set<String>> lastNamesByIndustry = (Map<String, Set<String>>) Stream.of(accounts)
    .collect(lastNamesByIndustryCollector); // { 'Technology' => {'Company A'}, 'Finance' => {'Company B', 'Company C'} }
```

Example 4: Grouping by Multiple Fields

```apex
List<Account> accounts = new List<Account>{
    new Account(Name = 'John Doe', AnnualRevenue = 1000000, Industry = 'Technology', BillingCity = 'Los Angeles'),
    new Account(Name = 'Jane Smith', AnnualRevenue = 2000000, Industry = 'Finance', BillingCity = 'New York'),
    new Account(Name = 'Judy Roe', AnnualRevenue = 3000000, Industry = 'Healthcare', BillingCity = 'Los Angeles'),
    new Account(Name = 'Jack Amber', AnnualRevenue = 4000000, Industry = 'Healthcare', BillingCity = 'New York'),
    new Account(Name = 'Jill Black', AnnualRevenue = 5000000, Industry = 'Technology', BillingCity = 'Los Angeles')
};
// Group account names by industry and by city
ICollector namesByIndustryAndCityCollector = new SCol()
    .groupingByString()
    .of(Map<String, List<String>>.class)
    .key(Account.Industry)
    .val(new SCol()
        .groupingByString()
        .of(List<String>.class)
        .key(Account.BillingCity)
        .val(Account.Name)
    );
Map<String, Map<String, List<String>>> namesByIndustryAndCity = (Map<String, Map<String, List<String>>>)
    Stream.of(accounts).collect(namesByIndustryAndCityCollector);
// {
//    'Technology': {
//        'Los Angeles': [ 'John Doe', 'Jill Black' ]
//    },
//    'Finance': {
//        'New York': [ 'Jane Smith' ]
//    },
//    'Healthcare': {
//        'Los Angeles': [ 'Judy Roe' ],
//        'New York': [ 'Jack Amber' ]
//    }
// }
```

Example 5: Getting the Aggregation of Grouped Values

```apex
List<Account> accounts = new List<Account>{
    new Account(Name = 'John Doe', AnnualRevenue = 1000000, Industry = 'Technology', BillingCity = 'Los Angeles'),
    new Account(Name = 'Jane Smith', AnnualRevenue = 2000000, Industry = 'Finance', BillingCity = 'New York'),
    new Account(Name = 'Judy Roe', AnnualRevenue = 3000000, Industry = 'Healthcare', BillingCity = 'Los Angeles'),
    new Account(Name = 'Jack Amber', AnnualRevenue = 4000000, Industry = 'Healthcare', BillingCity = 'New York'),
    new Account(Name = 'Jill Black', AnnualRevenue = 5000000, Industry = 'Technology', BillingCity = 'Los Angeles')
};
// Get the sum of annual revenue by industry
ICollector sumOfAnnualRevenuesByIndustryCollector = new SCol()
    .groupingByString()
    .key(Account.Industry)
    .val(new SCol().summingDouble().val(Account.AnnualRevenue));
Map<String, Object> lastNamesByIndustry = (Map<String, Object>) Stream.of(accounts)
    .collect(sumOfAnnualRevenuesByIndustryCollector);
// {
//     'Finance': 2000000.0,
//     'Healthcare': 7000000.0,
//     'Technology': 6000000.0
// }
```

The same way we can get other aggregations of grouped values such as avg, min, max, average, count, join, and so on.
⚠️ Due to a limitation in Apex, we can't set a custom value type for the result map.

#### Partition Collectors

Designed to partition `SObject` elements by `Predicate`.

Syntax:

```
instance
    .[target(partitioningBy)]
    .{supplier(of)}
    .[key(key)]
    .{value(val)}
```

- Target:

| Call             | Description                                   |
|------------------|-----------------------------------------------|
| `partitioningBy` | Defines that the elements will be partitioned |

- Supplier (Optional):

| Call | Description                                                        |
|------|--------------------------------------------------------------------|
| `of` | Defines a `Supplier` or value `Type` that generates an accumulator |

- Key:

| Call  | Description                                               |
|-------|-----------------------------------------------------------|
| `key` | A map key of partition by field, field name, or predicate |

- Value (Optional):

| Call  | Description                                                                        |
|-------|------------------------------------------------------------------------------------|
| `val` | Defines a custom downstream collector by field, field name, downstream or identity |

Examples

Example 1: Partition by Field

```apex
List<Contact> contacts = new List<Contact>{
    new Contact(DoNotCall = true, LastName = 'Doe'),
    new Contact(DoNotCall = false, LastName = 'Smith')
};
// Partition contacts by DoNotCall
ICollector partitionByDoNotCallCollector = new SCol()
    .partitioningBy()
    .key(Contact.DoNotCall);
Map<Boolean, List<Contact>> partitionedContacts = (Map<Boolean, List<Contact>>)
    Stream.of(contacts).collect(partitionByDoNotCallCollector);
// {
//   true => [{ DoNotCall: true, LastName: 'Doe' }],
//   false => [{ DoNotCall: false, LastName: 'Smith' }]
// }
```

Example 2: Partition Field Value by Predicate

```apex
List<Account> accounts = new List<Account>{
    new Account(Industry = 'Tech', Name = 'Account A'),
    new Account(Industry = 'Finance', Name = 'Account B')
};
// Partition accounts by Predicate and collect account names into Set
ICollector partitionByIndustryCollector = new SCol()
    .partitioningBy()
    .of(Set<String>.class)
    .key(new SDefPred().is(Account.Industry).eq().val('Tech'))
    .val(new SCol().toStringSet().val(Account.Name));
Map<Boolean, Set<String>> partitionedNames = (Map<Boolean, Set<String>>) Stream.of(accounts)
    .collect(partitionByIndustryCollector);
 // {
 //   true => { 'Account A' },
 //   false => { 'Account B' }
 // }
```

#### Join Collectors

Designed to collect elements into a string.

Syntax:

```
instance
    .[target(joining)]
    .{delimiter(del)}
    .{prefix(pre)}
    .{suffix(suf)}
    .[value(val)];
```

- Target:

| Call      | Description                                               |
|-----------|-----------------------------------------------------------|
| `joining` | Defines that the elements will be collected into a String |

- Delimiter (Optional):

| Call  | Description                                                                 |
|-------|-----------------------------------------------------------------------------|
| `del` | A string that will be used to separate the elements in the resulting string |

- Prefix (Optional):

| Call  | Description                                               |
|-------|-----------------------------------------------------------|
| `pre` | A string that will be used to prefix the resulting string |

- Suffix (Optional):

| Call  | Description                                               |
|-------|-----------------------------------------------------------|
| `suf` | A string that will be used to suffix the resulting string |

- Value:

| Call  | Description                                                   |
|-------|---------------------------------------------------------------|
| `val` | A string value to be joined by field, field name, or function |

Examples

Example 1: Join Field

```apex
List<Contact> contacts = new List<Contact>{
    new Contact(LastName = 'Doe'),
    new Contact(LastName = 'Smith'),
    new Contact(LastName = 'Roe')
};
// Join last names
ICollector joinedNamesCollector = new SCol()
    .joining()
    .val(Contact.LastName);
String joinedNames = (String) Stream.of(contacts)
    .collect(joinedNamesCollector); // 'DoeSmithRoe'
```

Example 2: Join Field with Delimiter, Prefix, and Suffix

```apex
// Join last names with delimiter, prefix, and suffix
ICollector joinedNamesWithDelimiterPrefixAndSuffixCollector = new SCol()
    .joining()
    .del(', ')
    .pre('[')
    .suf(']')
    .val(Contact.LastName);
String joinedNames = (String) Stream.of(contacts)
    .collect(joinedNamesWithDelimiterPrefixAndSuffixCollector); // '[Doe, Smith, Roe]'
```

#### Aggregate Collectors

Designed to aggregate elements.

```
instance
    .[target(
      | averagingInt
      | averagingLong
      | averagingDouble
      | summingInt
      | summingLong
      | summingDouble
      | counting
    )]
    .[value(val)];
```

- Target:

| Call              | Description                                           |
|-------------------|-------------------------------------------------------|
| `averagingInt`    | Defines that the elements will be averaged as Integer |
| `averagingLong`   | Defines that the elements will be averaged as Long    |
| `averagingDouble` | Defines that the elements will be averaged as Double  |
| `summingInt`      | Defines that the elements will be summed as Integer   |
| `summingLong`     | Defines that the elements will be summed as Long      |
| `summingDouble`   | Defines that the elements will be summed as Double    |
| `counting`        | Defines that the elements will be counted as Integer  |

- Value:

| Call  | Description                                                |
|-------|------------------------------------------------------------|
| `val` | A value to be aggregated by field, field name, or function |

Examples

Example 1: Get Sum of Field

```apex
List<Account> accounts = new List<Account>{
    new Account(NumberOfEmployees = 100),
    new Account(NumberOfEmployees = 200)
};
// Get a sum of number of employees
ICollector sumOfNumOfEmployeesCollector = new SCol()
    .summingInt()
    .val(Account.NumberOfEmployees);
Integer sumOfNumOfEmployees = (Integer) Stream.of(accounts)
    .collect(sumOfNumOfEmployeesCollector); // 300
```

Example 2: Get Average of Field

```apex
// Get an average of number of employees
ICollector averageOfNumOfEmployeesCollector = new SCol()
    .averagingInt()
    .val(Account.NumberOfEmployees);
Integer averageOfNumOfEmployees = (Integer) Stream.of(accounts)
    .collect(averageOfNumOfEmployeesCollector); // 150
```

Example 3: Count

```apex
// Get a count of number of employees
ICollector countOfNumOfEmployeesCollector = new SCol()
    .counting();
Integer countOfNumOfEmployees = (Integer) Stream.of(accounts)
    .collect(countOfNumOfEmployeesCollector); // 2
```

#### Filter Collectors

Designed to filter elements during collecting.

```
instance
    .[target(filtering)]
    .[filter(when)]
    .{downstream(to)};
```

- Target:

| Call        | Description                                |
|-------------|--------------------------------------------|
| `filtering` | Defines that the elements will be filtered |

- Filter:

| Call   | Description                                         |
|--------|-----------------------------------------------------|
| `when` | A function that will be used to filter the elements |

- Downstream (Optional):

| Call | Description                                                               |
|------|---------------------------------------------------------------------------|
| `to` | A downstream collector that will be used to collect the filtered elements |
|      | If not called, the default downstream collector will be `toList<SObject>` |

Examples

Example 1: Filtering by Field

```apex
List<Contact> contacts = new List<Contact>{
    new Contact(DoNotCall = true, LastName = 'Doe'),
    new Contact(DoNotCall = false, LastName = 'Smith')
};
// Filter contacts by DoNotCall
ICollector doNotCallContactsCollector = new SCol()
    .filtering()
    .when(Contact.DoNotCall, true);
List<Contact> doNotCallContacts = (List<Contact>) Stream.of(contacts)
    .collect(doNotCallContactsCollector); // [{ DoNotCall: true, LastName: 'Doe' }]
```

Example 2: Filtering by Field and Collecting Other Field Values to Set

```apex
// Filter contacts by DoNotCall and collect last names into Set
ICollector doNotCallContactsLastNamesCollector = new SCol()
    .filtering()
    .when(Contact.DoNotCall, true)
    .to(new SCol().toStringSet().val(Contact.LastName));
Set<String> doNotCallContactsLastNames = (Set<String>) Stream.of(contacts)
    .collect(doNotCallContactsLastNamesCollector); // { 'Doe' }
```

#### Map Collectors

Designed to map elements during collecting.

```
instance
    .[target(mapping)]
    .[value(val)]
    .{downstream(to)};
```

- Target:

| Call      | Description                              |
|-----------|------------------------------------------|
| `mapping` | Defines that the elements will be mapped |

- Value:

| Call  | Description                                                      |
|-------|------------------------------------------------------------------|
| `val` | A value to be mapped by field, field name, function, or identity |

- Downstream (Optional):

| Call | Description                                                               |
|------|---------------------------------------------------------------------------|
| `to` | A downstream collector that will be used to collect the mapped elements   |
|      | If not called, the default downstream collector will be `toList<SObject>` |

Examples

Example 1: Map Fields

```apex
List<Contact> contacts = new List<Contact>{
    new Contact(Email = 'john.doe@example.com'),
    new Contact(Email = 'jane.smith@example.com')
};
// Map Emails
ICollector emailCollector = new SCol()
    .mapping()
    .val(Contact.Email);
List<Object> emails = (List<Object>) Stream.of(contacts)
    .collect(emailCollector); // ['john.doe@example.com', 'jane.smith@example.com']
```

Example 2: Map Fields and Collect into Set

```apex
// Map Emails and collect into Set
ICollector emailSetCollector = new SCol()
    .mapping()
    .val(Contact.Email) 
    .to(new SCol().toStringSet());
Set<String> emailSet = (Set<String>) Stream.of(contacts)
    .collect(emailSetCollector); // { 'john.doe@example.com', 'jane.smith@example.com' }
```

#### Flat Map Collectors

Designed to flat map elements during collecting.

```
instance
    .[target(flatMapping)]
    .[value(val)]
    .{downstream(to)};
```

- Target:

| Call          | Description                                   |
|---------------|-----------------------------------------------|
| `flatMapping` | Defines that the elements will be flat mapped |

- Value:

| Call  | Description                                                                           |
|-------|---------------------------------------------------------------------------------------|
| `val` | A value to be flat mapped by relationship field, relationship field name, or function |

- Downstream (Optional):

| Call | Description                                                                  |
|------|------------------------------------------------------------------------------|
| `to` | A downstream collector that will be used to collect the flat mapped elements |
|      | If not called, the default downstream collector will be `toList<SObject>`    |

Example:

```apex
List<Account> accounts = new List<Account>{
    new Account(Contacts = new List<Contact>{
        new Contact(LastName = 'Doe'),
        new Contact(LastName = 'Smith')
    }),
    new Account(Contacts = new List<Contact>{
        new Contact(LastName = 'Alex'),
        new Contact(LastName = 'Miller')
    })
};
// Flatten Contacts
ICollector contactsCollector = new SCol()
    .flatMapping()
    .val(Contact.AccountId/*or 'Contacts'*/);
List<Contact> allContacts = (List<Contact>) Stream.of(accounts)
    .collect(contactsCollector);
// [{ LastName: 'Doe'), { LastName: 'Smith' }, { LastName: 'Alex' }, { LastName: 'Miller' }]
```

#### Fold Collectors

Designed to fold elements during collecting.

```
instance
    .[target(folding)]
    .[value(val)]
    .[accumulator(acc)];

OR

instance
    .[target(folding)]
    .[accumulator(acc)];
```

- Target:

| Call      | Description                                                                |
|-----------|----------------------------------------------------------------------------|
| `folding` | Defines that the elements will be folded starting with provided `identity` |

- Value:

| Call  | Description                                                      |
|-------|------------------------------------------------------------------|
| `val` | A value to be folded by field, field name, function, or identity |

- Accumulator:

| Call  | Description                                                        |
|-------|--------------------------------------------------------------------|
| `acc` | An accumulator `BiOperator` that will be used to fold the elements |

Example:

```apex
public class SumDoubleFieldFolder extends BiOperator {
    private final String fieldName;
    public SumDoubleFieldFolder(String fieldName) { this.fieldName = fieldName; }
    public override Object apply(Object seed, Object o) {
        ((SObject) seed).put(
            fieldName,
            (Double) ((SObject) seed).get(fieldName) + (Double) ((SObject) o).get(fieldName)
        );
        return seed;
    }
}
List<Account> accounts = new List<Account>{
    new Account(AnnualRevenue = 500000.0),
    new Account(AnnualRevenue = 1000000.0)
};
Account seed = new Account(Name = 'Account A', AnnualRevenue = 0);
// 
ICollector sumCollector = new SCol()
    .folding(seed)
    .acc(new SumDoubleFieldFolder('AnnualRevenue'));
Account sum = (Account) Stream.of(accounts)
    .collect(sumCollector); // { Name: 'Account A', AnnualRevenue: 1500000.0 }
```

#### Reduce Collectors

Designed to reduce elements during collecting.
Produces a similar result as folding collector, but takes the first element as the initial accumulator value
and returns `Optional`.

```
instance
    .[target(reducing)]
    .[accumulator(acc)];
```

- Target:

| Call       | Description                                                                 |
|------------|-----------------------------------------------------------------------------|
| `reducing` | Defines that the elements will be reduced starting with provided `identity` |

- Accumulator:

| Call  | Description                                                          |
|-------|----------------------------------------------------------------------|
| `acc` | An accumulator `BiOperator` that will be used to reduce the elements |

Example:

```apex
public class SumDoubleFieldReducer extends BiOperator {
    private final String fieldName;
    public SumDoubleFieldReducer(String fieldName) { this.fieldName = fieldName; }
    public override Object apply(Object seed, Object o) {
        ((SObject) seed).put(
            fieldName,
            (Double) ((SObject) seed).get(fieldName) + (Double) ((SObject) o).get(fieldName)
        );
        return seed;
    }
}
List<Account> accounts = new List<Account>{
    new Account(Name = 'Account A', AnnualRevenue = 500000.0),
    new Account(Name = 'Account B', AnnualRevenue = 1000000.0)
};
ICollector sumCollector = new SCol()
    .reducing()
    .acc(new SumDoubleFieldReducer('AnnualRevenue'));
IOptional sum = (IOptional) Stream.of(accounts)
    .collect(sumCollector);
sum.get(); // { Name: 'Account A', AnnualRevenue: 1500000.0 }
```

#### Min and Max Collectors

Designed to reduce elements comparing during collecting.

```
instance
    .[target(
      | minimizing
      | maximizing
    )]
    .[value(val)];
```

- Target:

| Call         | Description                                 |
|--------------|---------------------------------------------|
| `minimizing` | Defines that the elements will be minimized |
| `maximizing` | Defines that the elements will be maximized |

- Value:

| Call  | Description                                                        |
|-------|--------------------------------------------------------------------|
| `val` | A value to be compared by field, field name, function, or comparer |

Example:

```apex
List<Account> accounts = new List<Account>{
    new Account(Name = 'Account A', AnnualRevenue = 500000.0),
    new Account(Name = 'Account B', AnnualRevenue = 1000000.0)
};
ICollector maxRevenueCollector = new SCol()
    .maximizing()
    .val(Account.AnnualRevenue);
IOptional max = (IOptional) Stream.of(accounts)
    .collect(maxRevenueCollector);
max.get(); // { Name: 'Account B', AnnualRevenue: 1000000.0 }
```

### Cross-Reference Fields and Safe Navigation

Cross-reference fields and safe navigation are fully supported in Apex Common Functions V2.
It means that for any method that accepts a `SObjectField` we can also pass a `String` field name.

Example:

```apex
// Get a Name.
IFunction nameMapper = new SFn().get('Name');
nameMapper.apply(new Account(Name = 'John Doe')); // John Doe
```

We can also get a value for a cross-reference field.

```apex
// Get a Name of the Parent.
IFunction parentNameMapper = new SFn().get('Parent.Name');
parentNameMapper.apply(new Account(Name = 'John Doe', Parent = new Account(Name = 'Sam Doe'))); // Sam Doe
// but
parentNameMapper.apply(new Account(Name = 'John Doe')); // throws NPE
```

To prevent NPE, we can use safe navigation (?.)

```apex
// Get a Name of the Parent.
IFunction parentNameMapper = new SFn().get('Parent?.Name');
parentNameMapper.apply(new Account(Name = 'John Doe', Parent = new Account(Name = 'Sam Doe'))); // Sam Doe
// but
parentNameMapper.apply(new Account(Name = 'John Doe')); // null
```

# 🗓️ Next Steps

- Full Release of Apex Common Functions V2: I plan to move from a pilot release to a full release after incorporating feedback and ensuring stability.
- Additional Features: Upcoming features include enhanced support for complex data structures and more intuitive chaining methods.
- Documentation Updates: I will continue to improve the documentation, including more examples and best practices.

Please share your experiences with Apex Common Functions V2 to help to improve future releases!
