/**
 * @description A sequence of `Long` elements supporting aggregate operations,
 * a primitive specialization of {@link ObjectStream}.
 *
 * @see SObjectStream
 * @see ObjectStream
 * @see DoubleStream
 * @see IntStream
 *
 * @author Oleh Berehovskyi
 *
 * @group Enumerables
 *
 * @example
 * Long sumAnnualRevenueOfUniquePeopleFromLondon
 *     = ObjectStream.of(people)
 *         .filter(isPersonFromLondonPredicate)
 *         .distinct()
 *         .mapToLong(getAnnualRevenueToLongFunction)
 *         .sum();
 */
@SuppressWarnings('PMD.CognitiveComplexity, PMD.ExcessivePublicCount')
public virtual inherited sharing class LongStream extends LongEnumerable implements IRunnable {

    private final transient Iterator<Long> iterator;

    /**
     * @description A flag defining whether this stream has been linked or consumed.
     */
    public Boolean isOperated { get { return isOperated; } protected set; } {
        isOperated = false;
    }

    protected LongStream() {
        this(new List<Long>().iterator());
    }

    protected LongStream(final Iterator<Long> iterator) {
        this.iterator = iterator;
    }

    //<editor-fold desc="Iterator">
    // @start-group Iterator
    /**
     * @description Returns an internal iterator for the elements of this stream.
     * <p>Terminal Operation.</p>
     *
     * @return the internal `Iterator<Long>`
     *
     * @throws IllegalArgumentException if this stream has been operated (linked or consumed)
     */
    public override Iterator<Long> iterator() {
        Validate.isTrue(!isOperated, Label.AS_ErrorMessage_StreamOperated);
        try {
            return iterator;
        } finally {
            isOperated = true;
        }
    }
    // @end-group
    //</editor-fold>

    //<editor-fold desc="Sources">
    // @start-group Sources
    /**
     * @description Returns a `LongEnumerable` created from `iterator`.
     *
     * @param iterator the iterator
     *
     * @return the new `LongEnumerable`
     *
     * @throws NullPointerException if `iterator` is null
     *
     * @example
     * LongEnumerable longStream = LongStream.of(new List<Long>{ 0, 5L, 1L, -10 }.iterator());
     * LongEnumerable longStream = LongStream.of(new Set<Long>{ 0, 5L, 1L, -10 }.iterator());
     * LongEnumerable longStream = LongStream.of(otherStream.iterator());
     */
    public static LongEnumerable of(final Iterator<Long> iterator) {
        Validate.notNull(iterator);
        return new LongStream(iterator);
    }

    /**
     * @description Returns a `LongEnumerable` created from `longs`.
     *
     * @param longs the iterable
     *
     * @return the new `LongEnumerable`
     *
     * @throws NullPointerException if `longs` is null
     *
     * @example
     * LongEnumerable longStream = LongStream.of(new List<Long>{ 0, 5L, 1L, -10 });
     * LongEnumerable longStream = LongStream.of(new Set<Long>{ 0, 5L, 1L, -10 });
     */
    public static LongEnumerable of(final Iterable<Long> longs) {
        Validate.notNull(longs);
        return new LongStream(longs.iterator());
    }

    /**
     * @description Returns a `LongEnumerable` created from `longs` if non-null,
     * otherwise returns an empty `LongEnumerable`.
     *
     * @param longs the iterable
     *
     * @return the new `LongEnumerable` if `longs` is non-null,
     * otherwise an empty `LongEnumerable`
     *
     * @example
     * LongEnumerable longStream = LongStream.ofNullable(new List<Long>{ 0, 5L, 1L, -10 });
     */
    public static LongEnumerable ofNullable(final Iterable<Long> longs) {
        if (longs == null) { return empty(); }
        return new LongStream(longs.iterator());
    }

    /**
     * @description Returns an empty `LongEnumerable`.
     *
     * @return the empty `LongEnumerable`
     */
    public static LongEnumerable empty() {
        return new LongStream();
    }

    /**
     * @description Returns an ordered `LongEnumerable`
     * from `fromLong` (inclusive) to `toLong` (inclusive) by an incremental step of 1.
     *
     * @param fromLong the inclusive initial value
     * @param toLong the inclusive upper bound
     *
     * @return the new `LongEnumerable`
     *
     * @throws NullPointerException if `fromLong` or `toLong` is null
     *
     * @example
     * LongEnumerable longStreamFrom0To100 = LongStream.range(0, 100);
     */
    public static LongEnumerable range(final Long fromLong, final Long toLong) {
        return new LongStream(StreamPipeline.rangeLong(fromLong, toLong));
    }

    /**
     * @description Returns an infinite `LongEnumerable` where each element is
     * generated by `supplier`.
     *
     * @param supplier the supplier of generated elements
     *
     * @return the new `LongEnumerable`
     *
     * @throws NullPointerException if `supplier` is null
     *
     * @example
     * public class FibonacciSupplier extends Supplier {
     *     private Long n0 = 1;
     *     private Long n1 = 1;
     *     public override Object get() {
     *         Long n2 = n0 + n1;
     *         n0 = n1;
     *         n1 = n2;
     *         return n0;
     *     }
     * }
     * LongEnumerable fibonacciInfiniteStream = LongStream.generate(new FibonacciSupplier());
     * Iterator<Long> it = fibonacciInfiniteStream.iterator();
     * it.next(); // 1L
     * it.next(); // 2L
     * it.next(); // 3L
     * it.next(); // 5L
     * it.next(); // 8L
     */
    public static LongEnumerable generate(final ISupplier supplier) {
        return new LongStream((Iterator<Long>) StreamPipeline.generate(supplier));
    }

    /**
     * @description Returns an infinite `LongEnumerable` produced by iterative
     * application of `operator` to an initial element `seed`,
     * producing a `LongEnumerable` consisting of `seed`, `operator(seed)`,
     * `operator(operator(seed))`, etc.
     *
     * @param seed the initial element
     * @param operator the operator to be applied to the previous element to produce a new element
     *
     * @return the new `LongEnumerable`
     *
     * @throws NullPointerException if `supplier` is null
     *
     * @example
     * public class AddOperator extends Operator {
     *     private final Long i;
     *     public AddOperator(Long d) { this.i = i; }
     *     public override Object apply(Object j) { return (Long) j + i; }
     * }
     * LongEnumerable incrementalStream = LongStream.iterate(0L, new AddOperator(1L));
     * Iterator<Long> it = incrementalStream.iterator();
     * it.next(); // 0L
     * it.next(); // 1L
     * it.next(); // 2L
     */
    public static LongEnumerable iterate(final Long seed, final IOperator operator) {
        return new LongStream((Iterator<Long>) StreamPipeline.iterate(seed, operator));
    }

    /**
     * @description Returns an infinite `LongEnumerable` produced by iterative
     * application of `operator` to an initial element `seed`,
     * conditioned on satisfying `predicate`.
     *
     * @param seed the initial element
     * @param predicate the predicate to determine when the stream must be terminated
     * @param operator the operator to be applied to the previous element to produce a new element
     *
     * @return the new `LongEnumerable`
     *
     * @throws NullPointerException if `supplier` or `supplier` is null
     *
     * @example
     * public class IsLessPredicate extends Predicate {
     *     private final Long d;
     *     public IsLessPredicate(Long d) { this.d = d; }
     *     public override Boolean test(Object o) { return (Long) o < d; }
     * }
     * public class AddOperator extends Operator {
     *     private final Long d;
     *     public AddOperator(Long d) { this.d = d; }
     *     public override Object apply(Object j) { return (Long) j + d; }
     * }
     * List<Long> longs = LongStream.iterate(
     *     0,
     *     new IsLessPredicate(5L),
     *     new AddOperator(1L)
     * ).toList(); // [0L, 1L, 2L, 3L, 4L]
     */
    public static LongEnumerable iterate(final Long seed, final IPredicate predicate, final IOperator operator) {
        return iterate(seed, operator).take(predicate);
    }

    /**
     * @description Returns lazily concatenated `LongEnumerable` whose elements are all the
     * elements of the first `Iterable<Long>` followed by all the elements of the
     * second `Iterable<Long>`.
     *
     * @param iterable1 the first `Iterable<Long>`
     * @param iterable2 the second `Iterable<Long>`
     *
     * @return the new `LongEnumerable`
     *
     * @throws NullPointerException if `iterable1` or `iterable2` is null
     *
     * @example
     * List<Long> longs1 = new List<Long>{ 5L, 3L, 9L, 7L, 5L, 9L, 3L, 7L };
     * List<Long> longs2 = new List<Long>{ 8L, 3L, 6L, 4L, 4L, 9L, 1L, 0L };
     * List<Long> concat = LongStream.concat(longs1, longs2)
     *     .toList();
     * // [5L, 3L, 9L, 7L, 5L, 9L, 3L, 7L, 8L, 3L, 6L, 4L, 4L, 9L, 1L, 0L]
     */
    public static LongEnumerable concat(final Iterable<Long> iterable1, final Iterable<Long> iterable2) {
        return concat(new List<Iterable<Long>>{ iterable1, iterable2 });
    }

    /**
     * @description Returns lazily concatenated `List<Iterable<Long>>`.
     *
     * @param iterables the list of `Iterable<Long>`
     *
     * @return the new `LongEnumerable`
     *
     * @throws NullPointerException if `iterables` or some element in a list is null
     *
     * @example
     * List<Long> longs1 = new List<Long>{ 5L, 3L, 9L, 7L, 5L, 9L, 3L, 7L };
     * List<Long> longs2 = new List<Long>{ 8L, 3L, 6L, 4L, 4L, 9L, 1L, 0L };
     * List<Long> concat = LongStream.concat(new List<Iterable<Long>>{ longs1, longs2 })
     *     .toList();
     * // [5L, 3L, 9L, 7L, 5L, 9L, 3L, 7L, 8L, 3L, 6L, 4L, 4L, 9L, 1L, 0L]
     */
    public static LongEnumerable concat(final List<Iterable<Long>> iterables) {
        return new LongStream((Iterator<Long>) StreamPipeline.concat(iterables, Long.class));
    }

    /**
     * @description Returns a combined `LongEnumerable` by applying `combiner` function
     * to each element at the same position.
     *
     * @param iterable1 the first `Iterable<Long>`
     * @param iterable2 the second `Iterable<Long>`
     * @param combiner the binary operator to be applied to each element at the same position
     *
     * @return the new `LongEnumerable`
     *
     * @throws NullPointerException if `iterable1`, `iterable2` or `combiner` is null
     *
     * @example
     * public class SumBiOperator extends BiOperator {
     *     public override Object apply(Object o1, Object o2) { return (Long) o1 + (Long) o2; }
     * }
     * List<Long> longs1 = new List<Long>{ 5L, 3L, 9L, 7L, 5L, 9L, 3L, 7L };
     * List<Long> longs2 = new List<Long>{ 8L, 3L, 6L, 4L, 4L, 9L, 1L, 0L };
     * List<Long> zip = LongStream.zip(longs1, longs2, new SumBiOperator())
     *     .toList();
     * // [13L, 6L, 15L, 11L, 9L, 18L, 4L, 7L]
     */
    public static LongEnumerable zip(
        final Iterable<Long> iterable1,
        final Iterable<Long> iterable2,
        final IBiOperator combiner
    ) {
        return new LongStream((Iterator<Long>) StreamPipeline.zip(iterable1, iterable2, combiner));
    }

    /**
     * @description Returns new `LongEnumerable` by appending `iterable`
     * to the current stream.
     *
     * @param iterable the `Iterable<Long>` to append to the current stream
     *
     * @return the new `LongEnumerable`
     *
     * @throws NullPointerException if `iterable` is null
     *
     * @example
     * List<Long> longs1 = new List<Long>{ 5L, 3L, 9L, 7L, 5L, 9L, 3L, 7L };
     * List<Long> longs2 = new List<Long>{ 8L, 3L, 6L, 4L, 4L, 9L, 1L, 0L };
     * List<Long> append = LongStream.of(longs1)
     *     .append(longs2)
     *     .toList();
     * // [5L, 3L, 9L, 7L, 5L, 9L, 3L, 7L, 8L, 3L, 6L, 4L, 4L, 9L, 1L, 0L]
     */
    public virtual override LongEnumerable append(final Iterable<Long> iterable) {
        return concat(this, iterable);
    }

    /**
     * @description Returns new `LongEnumerable` by prepending `iterable`
     * to the current stream.
     *
     * @param iterable the `Iterable<Long>` to prepend to the current stream
     *
     * @return the new `LongEnumerable`
     *
     * @throws NullPointerException if `iterable` is null
     *
     * @example
     * List<Long> longs1 = new List<Long>{ 5L, 3L, 9L, 7L, 5L, 9L, 3L, 7L };
     * List<Long> longs2 = new List<Long>{ 8L, 3L, 6L, 4L, 4L, 9L, 1L, 0L };
     * List<Long> append = LongStream.of(longs1)
     *     .prepend(longs2)
     *     .toList();
     * // [8L, 3L, 6L, 4L, 4L, 9L, 1L, 0L, 5L, 3L, 9L, 7L, 5L, 9L, 3L, 7L]
     */
    public virtual override LongEnumerable prepend(final Iterable<Long> iterable) {
        return concat(iterable, this);
    }
    // @end-group
    //</editor-fold>

    //<editor-fold desc="Intermediate Operations">
    // @start-group Intermediate Operations
    /**
     * @description Returns a `LongEnumerable` with elements that match `predicate`.
     * <p>Stateless Intermediate Operation.</p>
     *
     * @param predicate the non-interfering, stateless predicate
     *
     * @return the `LongEnumerable`
     *
     * @throws NullPointerException if `predicate` is null
     *
     * @example
     * List<Long> filtered = LongStream.of(new List<Long>{ 0L, 5L, 1L, 1L, 5L })
     *     .filter(Predicates.isEqual(5L))
     *     .toList(); // [5L, 5L]
     */
    public virtual override LongEnumerable filter(final IPredicate predicate) {
        return new LongStream((Iterator<Long>) StreamPipeline.filter(iterator(), predicate));
    }

    /**
     * @description Returns a `LongEnumerable` which takes elements while elements match `predicate`.
     * <p>Short-circuiting Stateful Intermediate Operation.</p>
     *
     * @param predicate the non-interfering, stateless predicate
     *
     * @return the `LongEnumerable`
     *
     * @throws NullPointerException if `predicate` is null
     *
     * @example
     * List<Long> firstFiltered = LongStream.of(new List<Long>{ 0L, 0L, 1L, 1L, 5L })
     *     .take(Predicates.isEqual(0L))
     *     .toList(); // [0L, 0L]
     */
    public virtual override LongEnumerable take(final IPredicate predicate) {
        return new LongStream((Iterator<Long>) StreamPipeline.take(iterator(), predicate));
    }

    /**
     * @description Returns a `LongEnumerable` which drops elements while elements match `predicate`,
     * then takes the rest.
     * <p>Stateful Intermediate Operation.</p>
     *
     * @param predicate the non-interfering, stateless predicate
     *
     * @return the `LongEnumerable`
     *
     * @throws NullPointerException if `predicate` is null
     *
     * @example
     * List<Long> rest = LongStream.of(new List<Long>{ 0L, 0L, 1L, 1L, 5L })
     *     .drop(Predicates.isEqual(0L))
     *     .toList(); // [1L, 1L, 5L]
     */
    public virtual override LongEnumerable drop(final IPredicate predicate) {
        return new LongStream((Iterator<Long>) StreamPipeline.drop(iterator(), predicate));
    }

    /**
     * @description Returns a `LongEnumerable` with elements returned by `mapper` function,
     * applied to the elements of this stream.
     * <p>Stateless Intermediate Operation.</p>
     *
     * @param mapper the non-interfering, stateless operator
     *
     * @return the `LongEnumerable`
     *
     * @throws NullPointerException if `mapper` is null
     *
     * @example
     * public class MultiplyLongOperator extends Operator {
     *     private final Long l;
     *     public MultiplyLongOperator(Long l) { this.l = l; }
     *     public override Object apply(Object j) { return (Long) j * l; }
     * }
     * List<Long> doubledLongs = LongStream.of(new List<Long>{ 0L, 5L, 1L, -10L })
     *     .mapTo(new MultiplyLongOperator(2))
     *     .toList(); // [0L, 10L, 2L, -20L]
     */
    public virtual override LongEnumerable mapTo(final IOperator mapper) {
        return new LongStream((Iterator<Long>) StreamPipeline.mapTo(iterator(), (IFunction) mapper));
    }

    /**
     * @description Returns a `IntEnumerable` with elements returned by `mapper` function,
     * applied to the elements of this stream.
     * <p>Stateless Intermediate Operation.</p>
     *
     * @param mapper the non-interfering, stateless operator
     *
     * @return the `IntEnumerable`
     *
     * @throws NullPointerException if `mapper` is null
     *
     * @example
     * public class MultiplyIntFunction extends Function {
     *     private final Integer i;
     *     public MultiplyIntFunction(Integer i) { this.i = i; }
     *     public override Object apply(Object j) { return (Long) j * i; }
     * }
     * List<Integer> doubledInts = LongStream.of(new List<Long>{ 0L, 5L, 1L, -10L })
     *     .mapToLong(new MultiplyIntFunction(2))
     *     .toList(); // [0, 10, 2, -20]
     */
    public virtual override IntEnumerable mapToInt(final IFunction mapper) {
        return IntStream.of((Iterator<Integer>) StreamPipeline.mapTo(iterator(), mapper));
    }

    /**
     * @description Returns a `DoubleEnumerable` with elements returned by `mapper` function,
     * applied to the elements of this stream.
     * <p>Stateless Intermediate Operation.</p>
     *
     * @param mapper the non-interfering, stateless operator
     *
     * @return the `DoubleEnumerable`
     *
     * @throws NullPointerException if `mapper` is null
     *
     * @example
     * public class MultiplyDoubleFunction extends Function {
     *     private final Double d;
     *     public MultiplyDoubleFunction(Double d) { this.d = d; }
     *     public override Object apply(Object j) { return (Long) j * d; }
     * }
     * List<Double> doubledDoubles = LongStream.of(new List<Long>{ 0L, 5L, 1L, -10L })
     *     .mapToDouble(new MultiplyDoubleFunction(2))
     *     .toList(); // [0.0, 10.0, 2.0, -20.0]
     */
    public virtual override DoubleEnumerable mapToDouble(final IFunction mapper) {
        return DoubleStream.of((Iterator<Double>) StreamPipeline.mapTo(iterator(), mapper));
    }

    /**
     * @description Returns a `SObjectEnumerable` with elements returned by `mapper` function,
     * applied to the elements of this stream.
     * <p>Stateless Intermediate Operation.</p>
     *
     * @param mapper the non-interfering, stateless operator
     *
     * @return the `SObjectEnumerable`
     *
     * @throws NullPointerException if `mapper` is null
     *
     * @example
     * public class CreateAccountFunction extends Function {
     *     public override Object apply(Object i) { return new Account(AnnualRevenue = (Long) i); }
     * }
     * List<Account> accounts = LongStream.of(new List<Long>{ 0L, 5L, 1L, -10L })
     *     .mapToSObject(new CreateAccountFunction())
     *     .toList(); //
     * [
     *   { AnnualRevenue: 0 },
     *   { AnnualRevenue: 5 },
     *   { AnnualRevenue: 1 },
     *   { AnnualRevenue: 10 }
     * ]
     */
    public virtual override SObjectEnumerable mapToSObject(final IFunction mapper) {
        return SObjectStream.of((Iterator<SObject>) StreamPipeline.mapTo(iterator(), mapper));
    }

    /**
     * @description Returns a `ObjectEnumerable` with elements returned by `mapper` function,
     * applied to the elements of this stream.
     * <p>Stateless Intermediate Operation.</p>
     *
     * @param mapper the non-interfering, stateless operator
     *
     * @return the `ObjectEnumerable`
     *
     * @throws NullPointerException if `mapper` is null
     *
     * @example
     * public class ToStringFunction extends Function {
     *     public override Object apply(Object i) { return String.valueOf(i); }
     * }
     * List<String> strings = (List<String>) LongStream.of(new List<Long>{ 0L, 5L, 1L, -10L })
     *     .mapToObject(new ToStringFunction())
     *     .toList(String.class); // ['0', '5', '1', '10']
     */
    public virtual override ObjectEnumerable mapToObject(final IFunction mapper) {
        return ObjectStream.of(StreamPipeline.mapTo(iterator(), mapper));
    }

    /**
     * @description Returns a new `LongEnumerable` with `Long` elements as a result of
     * replacing each element with the contents of a mapped iterable created by applying
     * the specified `mapper` function to each element.
     * <p>Intermediate Operation.</p>
     *
     * @param mapper the mapping function which must produce `Iterable<Long>`
     *
     * @return the new `LongEnumerable`
     *
     * @throws NullPointerException if `mapper` is null
     *
     * @example
     * public class MultiplyLongFunction extends Function {
     *     private final Long l;
     *     public MultiplyLongFunction(Long l) { this.l = l; }
     *     public override Object apply(Object o) { return new List<Long>{ ((Long) o) * l }; }
     * }
     * List<Long> longs = LongStream.of(new List<Long>{ 0L, 5L, 1L, -10L })
     *     .flatMapTo(new MultiplyLongFunction(2L))
     *     .toList(); // [0L, 10L, 2L, -20L]
     */
    public virtual override LongEnumerable flatMapTo(final IFunction mapper) {
        return new LongStream((Iterator<Long>) StreamPipeline.flatMapTo(iterator(), mapper));
    }

    /**
     * @description Returns a `LongEnumerable` after performing `consumer` action on each element.
     * <p>Stateless Intermediate Operation.</p>
     *
     * @param consumer the non-interfering, stateless action to be performed on each element.
     * Expected to operate via side effects.
     *
     * @return the `LongEnumerable`
     *
     * @throws NullPointerException if `consumer` is null
     *
     * @example
     * public class DebugConsumer extends Consumer {
     *     public override void accept(Object o) { System.debug(o); }
     * }
     * List<Long> longs = LongStream.of(new List<Long>{ 0L, 5L, 1L, -10L })
     *     .forEach(new DebugConsumer()) // prints 0, 5, 1, -10
     *     .toList(); // [0L, 5L, 1L, -10L ]
     */
    public virtual override LongEnumerable forEach(final IConsumer consumer) {
        return new LongStream((Iterator<Long>) StreamPipeline.forEach(iterator(), consumer));
    }

    /**
     * @description Returns a `LongEnumerable` with distinct elements.
     * <p>Stateful Intermediate Operation.</p>
     *
     * @return the `LongEnumerable`
     *
     * @example
     * List<Long> distinct = LongStream.of(new List<Long>{ 0L, 5L, 1L, -10L, 0L, 5L })
     *     .distinct()
     *     .toList(); // [0L, 5L, 1L, -10L]
     */
    public virtual override LongEnumerable distinct() {
        return new LongStream((Iterator<Long>) StreamPipeline.distinct(iterator()));
    }

    /**
     * @description Returns a `LongEnumerable` with sorted elements in ascending order.
     * <p>Stateful Intermediate Operation.</p>
     *
     * @return the `LongEnumerable`
     *
     * @example
     * List<Long> sorted = LongStream.of(new List<Long>{ 0L, 5L, null, 1L, -10L })
     *     .sort()
     *     .toList(); // [null, -10L, 0L, 1L, 5L]
     */
    public virtual override LongEnumerable sort() {
        return new LongStream((Iterator<Long>) StreamPipeline.sort(iterator()));
    }

    /**
     * @description Returns a `LongEnumerable` with sorted elements considering `order`.
     * <p>Stateful Intermediate Operation.</p>
     *
     * @param order the sort order
     *
     * @return the `LongEnumerable`
     *
     * @throws NullPointerException if `order` is null
     *
     * @example
     * List<Long> sorted = LongStream.of(new List<Long>{ 0L, 5L, null, 1L, -10L })
     *     .sort(SortOrder.DESCENDING)
     *     .toList(); // [5L, 1L, 0L, -10L, null]
     */
    public virtual override LongEnumerable sort(final SortOrder order) {
        return new LongStream((Iterator<Long>) StreamPipeline.sort(iterator(), order));
    }

    /**
     * @description Returns a `LongEnumerable` with first `lim` elements.
     * <p>Short-circuiting Stateful Intermediate Operation.</p>
     *
     * @param lim the number of elements to limit
     *
     * @return the `LongEnumerable`
     *
     * @throws IllegalStateException if `lim` is less than 0
     * @throws NullPointerException if `lim` is null
     *
     * @example
     * List<Long> first3Longs = LongStream.of(new List<Long>{ 0L, 5L, 1L, -10L })
     *     .lim(3)
     *     .toList(); // [0L, 5L, 1L]
     */
    public virtual override LongEnumerable lim(final Integer lim) {
        return new LongStream((Iterator<Long>) StreamPipeline.lim(iterator(), lim));
    }

    /**
     * @description Returns a new `LongEnumerable` that skips first `n` elements
     * and returns remaining elements.
     * <p>Stateful Intermediate Operation.</p>
     *
     * @param n the number of elements to skip
     *
     * @return the `LongEnumerable`
     *
     * @throws IllegalStateException if `n` is less than 0
     * @throws NullPointerException if `n` is null
     *
     * @example
     * List<Long> restLongs = LongStream.of(new List<Long>{ 0L, 5L, 1L, -10L })
     *     .skip(1)
     *     .toList(); // [5L, 1L, -10L]
     */
    public virtual override LongEnumerable skip(final Integer n) {
        return new LongStream((Iterator<Long>) StreamPipeline.skip(iterator(), n));
    }
    // @end-group
    //</editor-fold>

    //<editor-fold desc="Terminal Operations">
    // @start-group Terminal Operations
    /**
     * @description Performs a reduction on `Long` elements,
     * using `identity` value and an associative `accumulator` function, and returns the reduced value.
     * <p>Terminal Operation.</p>
     *
     * @param identity the identity value for `accumulator`
     * @param accumulator the associative, non-interfering, stateless accumulation function
     *
     * @return the `Long` result of the reduction
     *
     * @throws NullPointerException if `accumulator` is null
     *
     * @example
     * public class SumBiOperator extends BiOperator {
     *     public override Object apply(Object o1, Object o2) { return (Long) o1 + (Long) o2; }
     * }
     * public class ProductBiOperator extends BiOperator {
     *     public override Object apply(Object o1, Object o2) { return (Long) o1 * (Long) o2; }
     * }
     * Long sum = LongStream.of(new List<Long>{ 0, 5L, 1L, -10 }).reduce(0L, new SumBiOperator()); // -4L
     * Long factorialOfN = LongStream.range(1, n).reduce(1, new ProductBiOperator());
     */
    public virtual override Long reduce(final Long identity, final IBiOperator accumulator) {
        return (Long) StreamPipeline.reduce(iterator(), (Object) identity, accumulator);
    }

    /**
     * @description Performs a reduction on `Long` elements,
     * using `identity` value and associative `accumulator` function, and returns
     * an `Optional` Long describing the reduced value.
     * <p>Terminal Operation.</p>
     *
     * @param accumulator the associative, non-interfering, stateless accumulation function
     *
     * @return the `Optional` Long result of the reduction
     *
     * @throws NullPointerException if `accumulator` is null
     *
     * @example
     * public class SumBiOperator extends BiOperator {
     *     public override Object apply(Object o1, Object o2) { return (Long) o1 + (Long) o2; }
     * }
     * Long sum = (Long) LongStream.of(new List<Long>{ 0L, 5L, 1L, -10L })
     *     .reduce(new SumBiOperator())
     *     .get(); // -4L
     */
    public virtual override Optional reduce(final IBiOperator accumulator) {
        return Optional.ofNullable((Long) StreamPipeline.reduce(iterator(), accumulator));
    }

    /**
     * @description Performs a mutable reduction operation on elements, collecting elements
     * to a container using `collector`.
     * <p>Terminal Operation.</p>
     *
     * @param collector the function that returns a mutable result container
     *
     * @return the `Object` result of the collection
     *
     * @throws NullPointerException if `collector` is null
     *
     * @example
     * public class AddToLongSetBiConsumer extends BiConsumer {
     *     public override void accept(Object container, Object o) { ((Set<Long>) container).add((Long) o); }
     * }
     * Set<Long> longs = (Set<Long>)
     *     LongStream.of(new List<Long>{ 0L, 5L, 1L, -10L, 5L, 0L })
     *     .collect(Collector.of(Supplier.of(Set<Long>.class), new AddToLongSetBiConsumer()));
     * // [0L, 5L, 1L, -10L]
     */
    public virtual override Object collect(final ICollector collector) {
        return StreamPipeline.collect(iterator(), collector);
    }

    /**
     * @description Returns an `Optional` Long describing the first element
     * that matches `predicate`.
     * <p>Short-circuiting Terminal Operation.</p>
     *
     * @param predicate the predicate
     *
     * @return the `Optional` Long
     *
     * @throws NullPointerException if `predicate` is null
     *
     * @example
     * public class IsEvenPredicate extends Predicate {
     *     public override Boolean test(Object o) { return Math.mod((Long) o, 2) == 0; }
     * }
     * Long firstEvenLong = (Long) LongStream.of(new List<Long>{ 0L, 5L, 1L, -10L })
     *     .find(new IsEvenPredicate())
     *     .get(); // 0L
     */
    public virtual override Optional find(final IPredicate predicate) {
        return Optional.ofNullable((Long) StreamPipeline.find(iterator(), predicate));
    }

    /**
     * @description Returns whether all elements match `predicate`.
     * If `LongEnumerable` is empty then `false` is returned.
     * <p>Short-circuiting Terminal Operation.</p>
     *
     * @param predicate the predicate
     *
     * @return `true` or `false`
     *
     * @throws NullPointerException if `predicate` is null
     *
     * @example
     * public class IsEvenPredicate extends Predicate {
     *     public override Boolean test(Object o) { return Math.mod((Long) o, 2) == 0; }
     * }
     * Boolean isEveryLongEven = LongStream.of(new List<Long>{ 0L, 5L, 1L, -10L })
     *     .every(new IsEvenPredicate()); // false
     */
    public virtual override Boolean every(final IPredicate predicate) {
        return StreamPipeline.match(iterator(), predicate, 1);
    }

    /**
     * @description Returns whether some element matches `predicate`.
     * If `LongEnumerable` is empty then `false` is returned.
     * <p>Short-circuiting Terminal Operation.</p>
     *
     * @param predicate the predicate
     *
     * @return `true` or `false`
     *
     * @throws NullPointerException if `predicate` is null
     *
     * @example
     * public class IsEvenPredicate extends Predicate {
     *     public override Boolean test(Object o) { return Math.mod((Long) o, 2) == 0; }
     * }
     * Boolean isSomeLongEven = LongStream.of(new List<Long>{ 0L, 5L, 1L, -10L })
     *     .some(new IsEvenPredicate()); // true
     */
    public virtual override Boolean some(final IPredicate predicate) {
        return StreamPipeline.match(iterator(), predicate, 0);
    }

    /**
     * @description Returns the sum of elements.
     * <p>Terminal Operation.</p>
     *
     * @return the sum of elements
     *
     * @example
     * Long sum = LongStream.of(new List<Long>{ 0L, 5L, 1L, -10L })
     *     .sum(); // -4L
     */
    public virtual override Long sum() {
        return (Long) StreamPipeline.avgLong(iterator(), false);
    }

    /**
     * @description Returns `Optional` Double describing the arithmetic mean of elements of this stream,
     * or an empty `Optional` Double if this stream is empty.
     * <p>Terminal Operation.</p>
     *
     * @return the arithmetic mean of elements
     *
     * @example
     * Double avg = (Double) LongStream.of(new List<Long>{ 0L, 5L, 1L, -10L })
     *     .avg()
     *     .get(); // 1.0
     */
    public virtual override Optional avg() {
        return Optional.of((Double) StreamPipeline.avgLong(iterator(), true));
    }

    /**
     * @description Returns the count of elements.
     * <p>Terminal Operation.</p>
     *
     * @return the count of elements
     *
     * @example
     * Integer count = LongStream.of(new List<Long>{ 0L, 5L, 1L, -10L })
     *     .count(); // 4
     */
    public virtual override Integer count() {
        return StreamPipeline.count(iterator());
    }

    /**
     * @description Returns whether the count of elements is 0.
     * <p>Terminal Operation.</p>
     *
     * @return `true` or `false`
     *
     * @example
     * LongStream.of(new List<Long>{ 0L, 5L, 1L, -10L })
     *     .isEmpty(); // false
     * LongStream.of(new List<Long>())
     *     .isEmpty(); // true
     */
    public virtual override Boolean isEmpty() {
        return StreamPipeline.isEmpty(iterator());
    }

    /**
     * @description Accumulates elements into a `List<Long>`.
     * <p>Terminal Operation.</p>
     *
     * @return the `List<Long>` containing the stream elements
     *
     * @example
     * List<Long> longs = LongStream.of(new List<Long>{ 0L, 5L, 1L, -10L })
     *     .skip(1)
     *     .toList(); // [5L, 1L, -10L]
     */
    public virtual override List<Long> toList() {
        return (List<Long>) StreamPipeline.toList(iterator(), Long.class);
    }

    /**
     * @description Accumulates elements into a `Set<Long>`.
     * <p>Terminal Operation.</p>
     *
     * @return the `Set<Long>` containing the stream elements
     *
     * @example
     * SSet<Long> longs = LongStream.of(new List<Long>{ 0L, 5L, 1L, -10L })
     *     .skip(1)
     *     .toSet(); // [5L, 1L, -10L, 0L]
     */
    public virtual override Set<Long> toSet() {
        return StreamPipeline.toLongSet(iterator());
    }

    /**
     * @description Advances the iterator to its end.
     * <p>Terminal Operation.</p>
     *
     * @example
     * public class DebugConsumer extends Consumer {
     *     public override void accept(Object o) { System.debug(o); }
     * }
     * IRunnable longStream = (IRunnable) LongStream.of(new List<Long>{ 0L, 5L, 1L, -10L })
     *     .forEach(new DebugConsumer());
     * // the `forEach` intermediate operation will not be performed until a terminal operation is initiated
     * longStream.run(); // prints 0, 5, 1, -10
     */
    public void run() {
        StreamPipeline.run(iterator());
    }
    // @end-group
    //</editor-fold>

}
